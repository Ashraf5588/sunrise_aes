<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Theme Evaluation Form</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #87CEEB 0%, #E0F6FF 50%, #B0E0E6 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #1a1a1a;
      min-height: 100vh;
      line-height: 1.6;
    }

    .nav-header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 1rem 0;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .nav-header h1 {
      text-align: center;
      color: #2c3e50;
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
    }

    .container {
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    .form-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 2rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .form-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .form-header h1 {
      color: #2c3e50;
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .form-header p {
      color: #7f8c8d;
      font-size: 1rem;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .form-group {
      position: relative;
    }

    .form-group.full-width {
      grid-column: 1 / -1;
    }

    label {
      display: block;
      margin-bottom: 0.5rem;
      color: #34495e;
      font-weight: 600;
      font-size: 0.9rem;
    }

    input[type="text"], 
    input[type="number"], 
    input[type="date"],
    select {
      width: 100%;
      padding: 0.875rem 1rem;
      border: 2px solid #e9ecef;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.8);
      color: #2c3e50;
    }

    input[type="text"]:focus, 
    input[type="number"]:focus, 
    input[type="date"]:focus,
    select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
      background: rgba(255, 255, 255, 1);
    }

    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 0.75rem center;
      background-repeat: no-repeat;
      background-size: 1.5em 1.5em;
      padding-right: 2.5rem;
    }

    .learning-outcome-section {
      margin-top: 2rem;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .learning-outcome-section h2 {
      color: #2c3e50;
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid #3498db;
    }

    .evaluation-table {
      width: 100%;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      background: white;
      margin-top: 1rem;
    }

    .evaluation-table th {
      background: linear-gradient(135deg, #3498db, #2980b9);
      color: white;
      padding: 1rem 0.75rem;
      font-weight: 600;
      font-size: 0.875rem;
      text-align: center;
      border: none;
    }

    .evaluation-table td {
      padding: 1rem 0.75rem;
      text-align: center;
      border: 1px solid #ecf0f1;
      background: rgba(255, 255, 255, 0.9);
    }

    .evaluation-table tr:nth-child(even) td {
      background: rgba(52, 152, 219, 0.02);
    }

    .section-header {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
      text-align: center;
      font-weight: 600;
      padding: 0.75rem;
    }

    .tools-header {
      background: linear-gradient(135deg, #f39c12, #e67e22);
      color: white;
      text-align: center;
      font-weight: 600;
      padding: 0.75rem;
    }

    .custom-checkbox {
      position: relative;
      display: inline-block;
      width: 24px;
      height: 24px;
      cursor: pointer;
    }

    .custom-checkbox input[type="checkbox"] {
      opacity: 0;
      position: absolute;
      width: 100%;
      height: 100%;
      margin: 0;
      cursor: pointer;
      z-index: 1;
    }

    .checkbox-custom {
      width: 24px;
      height: 24px;
      border: 2px solid #bdc3c7;
      border-radius: 6px;
      display: inline-block;
      position: relative;
      transition: all 0.3s ease;
      background: white;
      pointer-events: none;
    }

    .custom-checkbox input[type="checkbox"]:checked + .checkbox-custom {
      background: #3498db;
      border-color: #3498db;
      transform: scale(1.05);
    }

    .custom-checkbox input[type="checkbox"]:checked + .checkbox-custom::after {
      content: '✓';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-weight: bold;
      font-size: 14px;
      opacity: 1;
      animation: checkmark 0.3s ease-in-out;
    }

    @keyframes checkmark {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    .custom-checkbox:hover .checkbox-custom {
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
    }
    
    /* Marks input styling */
    .marks-input-container {
      width: 100%;
      display: flex;
      justify-content: center;
    }
    
    input.marks-input {
      width: 50px;
      text-align: center;
      padding: 4px;
      border: 1px solid #bdc3c7;
      border-radius: 6px;
      background-color: #fff;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    input.marks-input:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
    }
    
    input.marks-input:hover {
      border-color: #3498db;
    }
    
    /* Custom styling for input[type="number"] */
    input.marks-input::-webkit-outer-spin-button,
    input.marks-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    input.marks-input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    input[type="text"].tools-input {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 0.5rem;
      font-size: 0.875rem;
    }

    .totals-section {
      margin-top: 2rem;
      padding: 1.5rem;
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      border-radius: 16px;
      border: 1px solid #dee2e6;
    }

    .totals-section h3 {
      color: #2c3e50;
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 1rem;
      text-align: center;
    }

    .totals-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .total-item {
      background: white;
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .total-item.full-width {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-around;
      background: rgba(52, 152, 219, 0.1);
    }
    
    .outcome-totals-box {
      margin-top: 1rem;
      margin-bottom: 2rem;
      padding: 0.75rem;
      background: linear-gradient(135deg, #e8f4f8, #d1ecf1);
      border-radius: 12px;
      border: 1px solid #bee5eb;
    }
    
    .outcome-totals-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }
    
    .outcome-total-item {
      background: white;
      padding: 0.75rem;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    
    .outcome-total-item label {
      display: block;
      font-size: 0.8rem;
      color: #5d6778;
      margin-bottom: 0.25rem;
    }
    
    .outcome-total-item .total-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #3498db;
    }

    .total-item label {
      font-size: 0.875rem;
      color: #7f8c8d;
      margin-bottom: 0.5rem;
    }

    .total-item input {
      font-size: 1.125rem;
      font-weight: 600;
      text-align: center;
      background: #f8f9fa;
      border: 1px solid #e9ecef;
    }

    .submit-btn {
      background: linear-gradient(135deg, #27ae60, #229954);
      color: white;
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      margin-top: 2rem;
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
    }

    .submit-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
    }

    .submit-btn:active {
      transform: translateY(0);
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .container {
        margin: 1rem auto;
        padding: 0 0.5rem;
      }

      .form-card {
        padding: 1.5rem;
        border-radius: 16px;
      }

      .form-row {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .nav-header h1 {
        font-size: 1.25rem;
        padding: 0 1rem;
      }

      .form-header h1 {
        font-size: 1.5rem;
      }

      .evaluation-table {
        font-size: 0.875rem;
      }

      .evaluation-table th,
      .evaluation-table td {
        padding: 0.75rem 0.5rem;
      }

      .totals-grid {
        grid-template-columns: 1fr;
      }

      .learning-outcome-section {
        padding: 1rem;
      }

      .totals-section {
        padding: 1rem;
      }
    }

    @media (max-width: 480px) {
      .evaluation-table {
        font-size: 0.75rem;
      }

      .evaluation-table th,
      .evaluation-table td {
        padding: 0.5rem 0.25rem;
      }

      .custom-checkbox {
        width: 20px;
        height: 20px;
      }

      .checkbox-custom {
        width: 20px;
        height: 20px;
      }
    }

    /* Loading state */
    .loading {
      opacity: 0.7;
      pointer-events: none;
    }

    /* Hidden elements */
    .learning-outcome-wrapper {
      display: none;
    }

    .learning-outcome-wrapper[style*="display: block"] {
      display: block !important;
    }
  </style>
</head>
<body>
<nav class="nav-header">
  <h1>Class <%= studentClass %><%=section%> - <%= subject %> Theme Evaluation</h1>
</nav>

<div class="container">
  <div class="form-card">
    <div class="form-header">
      <h1>Theme Evaluation Form</h1>
      <p>Complete the evaluation for your selected theme</p>
      <div style="margin-top: 10px;">
        <p style="font-size: 0.9rem; color: #3498db; padding: 8px 16px; background: rgba(52, 152, 219, 0.1); border-radius: 8px; border-left: 3px solid #3498db; margin-bottom: 8px;">
          <strong>Smart Data Loading:</strong> Just enter a roll number to see available themes and load previous evaluations!
        </p>
        <p style="font-size: 0.9rem; color: #27ae60; padding: 8px 16px; background: rgba(46, 204, 113, 0.1); border-radius: 8px; border-left: 3px solid #27ae60; margin-bottom: 8px;">
          <strong>Autosave enabled:</strong> Changes are automatically saved as you work!
        </p>
        <p style="font-size: 0.9rem; color: #e67e22; padding: 8px 16px; background: rgba(230, 126, 34, 0.1); border-radius: 8px; border-left: 3px solid #e67e22;">
          <strong>Easy Editing:</strong> Previous evaluations can be modified - just make your changes and they'll be saved!
        </p>
      </div>
    </div>
    
    <form action="/theme/form" method="POST" id="themeEvaluationForm" onsubmit="return validateAndSubmitAjax(event)">
      <!-- Student Information Section -->
      <div class="form-row">
        <div class="form-group">
          <label for="roll">Roll Number</label>
          <input type="text" name="roll" id="roll" required placeholder="Enter roll number">
        </div>
        <div class="form-group">
          <label for="name">Student Name</label>
          <input type="text" name="name" id="name" required placeholder="Enter student name">
        </div>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label for="studentClass">Class</label>
          <input type="text" name="studentClass" id="studentClass" required value="<%= studentClass %>" readonly>
        </div>
        <div class="form-group">
          <label for="section">Section</label>
          <input type="text" name="section" id="section" required value="<%= section %>" readonly>
        </div>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label for="subject">Subject</label>
          <input type="text" name="subjects[0][name]" id="subject" required value="<%= subject %>" readonly>
        </div>
        <div class="form-group">
          <label for="themeName">Theme Name</label>
          <select name="subjects[0][themes][0][themeName]" id="themeName" onchange="filterLearningOutcomes()" required>
            <option value="">Select a theme</option>
            <% themeData.forEach(theme => { %>
              <% theme.themes.forEach(themeitem => { %>
                <option value="<%= themeitem.themeName %>"><%= themeitem.themeName %></option>
              <% }) %>
            <% }) %>
          </select>
        </div>
      </div>

      <!-- Learning Outcomes Section -->
      <% themeData.forEach((themeDoc, themeDocIndex) => { %>
        <% themeDoc.themes.forEach((themeItem, themeItemIndex) => { %>
          <div class="learning-outcome-wrapper" data-theme="<%= themeItem.themeName %>" data-theme-index="<%= themeItemIndex %>">
          <% themeItem.learningOutcome.forEach((outcome, outcomeIndex) => { %>
            <div class="learning-outcome-section">
              <h2><%= outcome.learningOutcomeName %></h2>
              <input type="hidden" class="theme-field" name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][name]" value="<%= outcome.learningOutcomeName %>">
              
              <div class="form-group">
                <label for="evaluationDate_<%= themeItemIndex %>_<%= outcomeIndex %>">Evaluation Date</label>
                <input type="date" class="theme-field" name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][evaluationDate]" id="evaluationDate_<%= themeItemIndex %>_<%= outcomeIndex %>">
              </div>
              
              <table class="evaluation-table">
                <thead>
                  <tr>
                    <% outcome.indicators.forEach(indicator => { %>
                      <th><%= indicator.indicatorName %></th>
                    <% }); %>
                    <th>Total Marks</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <% outcome.indicators.forEach((indicator, indicatorIndex) => { %>
                      <td>
                        <input type="hidden" class="theme-field" name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][indicators][<%= indicatorIndex %>][name]" value="<%= indicator.indicatorName %>">
                        <input type="hidden" class="theme-field" name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][indicators][<%= indicatorIndex %>][maxMarks]" value="<%= indicator.indicatorsMarks %>">
                        <div class="marks-input-container">
                          <input type="number" 
                                 min="0" 
                                 max="<%= indicator.indicatorsMarks %>" 
                                 step="any" 
                                 data-max-marks="<%= indicator.indicatorsMarks %>"
                                 onchange="updateMarks(this, '<%= outcomeIndex %>', '<%= indicatorIndex %>', 'Before')"
                                 class="marks-input indicator-before"
                                 value="0">
                        </div>
                        <input type="hidden" 
                               class="theme-field"
                               name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][indicators][<%= indicatorIndex %>][marksBeforeIntervention]" 
                               value="0">
                      </td>
                    <% }); %>
                    <td>
                      <input type="number" 
                             id="totalBefore_<%= themeItemIndex %>_<%= outcomeIndex %>" 
                             class="theme-field"
                             name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][totalMarksBeforeIntervention]" 
                             readonly>
                    </td>
                  </tr>
                  <tr>
                    <td colspan="<%= outcome.indicators.length + 1 %>" class="section-header" style="color: #2980b9;">थप सहायता पछि (After Intervention)</td>
                  </tr>
                  <tr>
                    <% outcome.indicators.forEach((indicator, indicatorIndex) => { %>
                      <td>
                        <div class="marks-input-container">
                          <input type="number" 
                                 min="0" 
                                 max="<%= indicator.indicatorsMarks %>" 
                                 step="any" 
                                 data-max-marks="<%= indicator.indicatorsMarks %>"
                                 onchange="updateMarks(this, '<%= outcomeIndex %>', '<%= indicatorIndex %>', 'After')"
                                 class="marks-input indicator-after"
                                 value="0">
                        </div>
                        <input type="hidden" 
                               class="theme-field"
                               name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][indicators][<%= indicatorIndex %>][marksAfterIntervention]" 
                               value="0">
                      </td>
                    <% }); %>
                    <td>
                      <input type="number" 
                             id="totalAfter_<%= themeItemIndex %>_<%= outcomeIndex %>" 
                             class="theme-field"
                             name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][totalMarksAfterIntervention]" 
                             readonly>
                    </td>
                  </tr>
                  <tr>
                    <td colspan="<%= outcome.indicators.length + 1 %>" class="tools-header">प्रयोग गरिएको साधन (Tools Used)</td>
                  </tr>
                  <tr>
                    <% outcome.indicators.forEach((indicator, indicatorIndex) => { %>
                      <td>
                        <input type="text" class="theme-field tools-input" name="subjects[0][themes][0][learningOutcomes][<%= outcomeIndex %>][indicators][<%= indicatorIndex %>][toolsUsed]" placeholder="Tools used">
                      </td>
                    <% }); %>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              
              <!-- Individual outcome totals box -->
              <div class="outcome-totals-box">
                <div class="outcome-totals-grid">
                  <div class="outcome-total-item">
                    <label for="outcomeBeforeTotal_<%= themeItemIndex %>_<%= outcomeIndex %>">Before Intervention Total</label>
                    <div class="total-value" id="outcomeBeforeDisplay_<%= themeItemIndex %>_<%= outcomeIndex %>">0</div>
                  </div>
                  <div class="outcome-total-item">
                    <label for="outcomeAfterTotal_<%= themeItemIndex %>_<%= outcomeIndex %>">After Intervention Total</label>
                    <div class="total-value" id="outcomeAfterDisplay_<%= themeItemIndex %>_<%= outcomeIndex %>">0</div>
                  </div>
                </div>
              </div>
            </div>
          <% }); %>
          
          <!-- Overall theme totals -->
          <div class="totals-section">
            <h3>Overall Theme Totals</h3>
            <div class="totals-grid">
              <div class="total-item">
                <label for="overallTotalBefore_<%= themeItemIndex %>">Total Before Intervention</label>
                <input type="number" id="overallTotalBefore_<%= themeItemIndex %>" class="theme-field" name="subjects[0][themes][0][overallTotalBefore]" readonly>
              </div>
              <div class="total-item">
                <label for="overallTotalAfter_<%= themeItemIndex %>">Total After Intervention</label>
                <input type="number" id="overallTotalAfter_<%= themeItemIndex %>" class="theme-field" name="subjects[0][themes][0][overallTotalAfter]" readonly>
              </div>
              <div class="total-item full-width">
                <label>Total Learning Outcomes: <span id="totalOutcomes_<%= themeItemIndex %>">0</span></label>
                <label>Total Max Marks: <span id="totalMaxMarks_<%= themeItemIndex %>">0</span></label>
              </div>
            </div>
          </div>
          </div>
        <% }); %>
      <% }); %>
      
      <button type="submit" class="submit-btn">
        Save Evaluation
      </button>
    </form>
  </div>
</div>

  <script>
    function validateAndSubmitAjax(event, isAutosave = false) {
      if (event) {
        event.preventDefault();
      }
      
      try {
        // Get the selected theme
        const selectedTheme = document.getElementById('themeName').value;
        const activeWrapper = document.querySelector('.learning-outcome-wrapper[style*="display: block"], .learning-outcome-wrapper[style*="display:block"]');
        
        console.log('Selected theme:', selectedTheme);
        console.log('Active wrapper found:', !!activeWrapper);
        console.log('Is edit mode:', isEditMode);
        
        if (!activeWrapper) {
          if (!isAutosave) alert('Please select a theme');
          return false;
        }
        
        // Validate required fields
        const roll = document.getElementById('roll').value.trim();
        const name = document.getElementById('name').value.trim();
        
        if (!roll || !name) {
          if (!isAutosave) alert('Please fill in roll number and name');
          return false;
        }
        
        // If not autosaving, show a saving indicator
        if (!isAutosave) {
          showSavingIndicator();
        }
        
        // Create a completely new form with clean data structure
        const originalForm = document.getElementById('themeEvaluationForm');
        const newForm = document.createElement('form');
        newForm.action = originalForm.action;
        newForm.method = originalForm.method;
        newForm.style.display = 'none';
        
        // Helper function to add hidden inputs
        const addField = (name, value) => {
          const input = document.createElement('input');
          input.type = 'hidden';
          input.name = name;
          input.value = value !== undefined && value !== null ? value : '';
          newForm.appendChild(input);
        };
        
        // Add basic student information
        addField('roll', roll);
        addField('name', name);
        addField('studentClass', document.getElementById('studentClass').value);
        addField('section', document.getElementById('section').value);
        addField('subjects[0][name]', document.getElementById('subject').value);
        addField('subjects[0][themes][0][themeName]', selectedTheme);
        addField('updatedAt', new Date().toISOString());
        addField('isEditMode', isEditMode);
        
        // Process learning outcomes from the active wrapper
        const themeIndex = activeWrapper.dataset.themeIndex;
        let newOutcomeIndex = 0;
        
        // Find all learning outcome containers in the active wrapper
        const outcomeContainers = activeWrapper.querySelectorAll('h2');
        
        outcomeContainers.forEach((h2) => {
          const outcomeName = h2.textContent.trim();
          addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][name]`, outcomeName);
          
          // Find the next sibling elements until we hit another h2 or end of wrapper
          let currentElement = h2.nextElementSibling;
          let evaluationDate = '';
          let indicators = [];
          let totalBefore = 0;
          let totalAfter = 0;
          
          while (currentElement && currentElement.tagName !== 'H2') {
            // Check for evaluation date input
            if (currentElement.tagName === 'DIV' && currentElement.classList.contains('form-group')) {
              const dateInput = currentElement.querySelector('input[type="date"]');
              if (dateInput) {
                evaluationDate = dateInput.value;
              }
            }
            
            // Check for table with indicators
            if (currentElement.tagName === 'TABLE') {
              const beforeRow = currentElement.querySelector('tbody tr:first-child');
              const afterRow = currentElement.querySelector('tbody tr:nth-child(3)');
              const toolsRow = currentElement.querySelector('tbody tr:nth-child(5)');
              
              if (beforeRow) {
                const beforeInputs = beforeRow.querySelectorAll('.marks-input.indicator-before');
                const afterInputs = afterRow ? afterRow.querySelectorAll('.marks-input.indicator-after') : [];
                const toolsInputs = toolsRow ? toolsRow.querySelectorAll('input[type="text"]') : [];
                
                beforeInputs.forEach((input, indicatorIndex) => {
                  const maxMarks = parseFloat(input.dataset.maxMarks) || 0;
                  const beforeMarks = parseFloat(input.value) || 0;
                  const afterMarks = afterInputs[indicatorIndex] ? parseFloat(afterInputs[indicatorIndex].value) || 0 : 0;
                  const toolsUsed = toolsInputs[indicatorIndex] ? toolsInputs[indicatorIndex].value : '';
                  
                  // Try to get indicator name from the table header
                  const headers = currentElement.querySelectorAll('thead th');
                  const indicatorName = headers[indicatorIndex] ? headers[indicatorIndex].textContent.trim() : `Indicator ${indicatorIndex + 1}`;
                  
                  addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][indicators][${indicatorIndex}][name]`, indicatorName);
                  addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][indicators][${indicatorIndex}][maxMarks]`, maxMarks);
                  addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][indicators][${indicatorIndex}][marksBeforeIntervention]`, beforeMarks);
                  addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][indicators][${indicatorIndex}][marksAfterIntervention]`, afterMarks);
                  if (toolsUsed) {
                    addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][indicators][${indicatorIndex}][toolsUsed]`, toolsUsed);
                  }
                  
                  totalBefore += beforeMarks;
                  totalAfter += afterMarks;
                });
              }
            }
            
            currentElement = currentElement.nextElementSibling;
          }
          
          // Add evaluation date and totals
          if (evaluationDate) {
            addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][evaluationDate]`, evaluationDate);
          }
          addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][totalMarksBeforeIntervention]`, totalBefore);
          addField(`subjects[0][themes][0][learningOutcomes][${newOutcomeIndex}][totalMarksAfterIntervention]`, totalAfter);
          
          newOutcomeIndex++;
        });
        
        // Add overall totals
        const overallBeforeField = activeWrapper.querySelector(`#overallTotalBefore_${themeIndex}`);
        const overallAfterField = activeWrapper.querySelector(`#overallTotalAfter_${themeIndex}`);
        
        addField('subjects[0][themes][0][overallTotalBefore]', overallBeforeField ? overallBeforeField.value : '0');
        addField('subjects[0][themes][0][overallTotalAfter]', overallAfterField ? overallAfterField.value : '0');
        
        // Submit the form via AJAX instead of normal submit
        document.body.appendChild(newForm);
        console.log('Submitting clean form with', newForm.querySelectorAll('input').length, 'fields');
        
        // Convert to a structured object
        const formData = new FormData(newForm);
        const plainFormData = {};
        
        // Process form data into a structured object with proper nesting
        for (const [key, value] of formData.entries()) {
          // Check if this is a nested field (contains brackets)
          if (key.includes('[')) {
            // Parse the nested structure
            const parts = key.match(/([^\[\]]+)|\[([^\[\]]*)\]/g).map(part => 
              part.replace(/^\[|\]$/g, '') // Remove brackets
            );
            
            // Build the nested structure
            let current = plainFormData;
            for (let i = 0; i < parts.length - 1; i++) {
              const part = parts[i];
              // Create array or object if it doesn't exist
              if (/^\d+$/.test(parts[i+1])) {
                // Next part is a number, create array
                current[part] = current[part] || [];
              } else {
                current[part] = current[part] || {};
              }
              current = current[part];
            }
            
            // Set the value at the final level
            const lastPart = parts[parts.length - 1];
            current[lastPart] = value;
          } else {
            // Simple key-value pair
            plainFormData[key] = value;
          }
        }
        
        // Add flags
        plainFormData.ajax = 'true';
        if (isAutosave) {
          plainFormData.autosave = 'true';
        }
        if (isEditMode) {
          plainFormData.isEdit = 'true';
        }
        
        fetch('/theme/form', {
          method: 'POST',
          body: JSON.stringify(plainFormData),
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          if (data.success) {
            // If this was a manual save (not autosave), show success message
            if (!isAutosave) {
              // Set the form to edit mode after successfully saving
              isEditMode = true;
              updateSubmitButtonText(true);
              
              // Update the theme data in memory if it was returned
              if (data.themeData) {
                currentThemeData = data.themeData;
              }
              
              // Show edit mode notification
              showEditModeNotification();
              
              // Show success message
              const successMessage = document.createElement('div');
              successMessage.className = 'toast-message';
              successMessage.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M22 11.0857V12.0057C21.9988 14.1621 21.3005 16.2604 20.0093 17.9875C18.7182 19.7147 16.9033 20.9782 14.8354 21.5896C12.7674 22.201 10.5573 22.1276 8.53447 21.3803C6.51168 20.633 4.78465 19.2518 3.61096 17.4428C2.43727 15.6338 1.87979 13.4938 2.02168 11.342C2.16356 9.19029 2.99721 7.14205 4.39828 5.5028C5.79935 3.86354 7.69279 2.72111 9.79619 2.24587C11.8996 1.77063 14.1003 1.98806 16.07 2.86572" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M22 4L12 14.01L9 11.01" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <span>Evaluation ${isEditMode ? 'updated' : 'saved'} successfully!</span>
              `;
              successMessage.style.position = 'fixed';
              successMessage.style.top = '20px';
              successMessage.style.left = '50%';
              successMessage.style.transform = 'translateX(-50%)';
              successMessage.style.background = 'rgba(46, 204, 113, 0.95)';
              successMessage.style.color = 'white';
              successMessage.style.padding = '12px 24px';
              successMessage.style.borderRadius = '8px';
              successMessage.style.zIndex = '1000';
              successMessage.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
              successMessage.style.display = 'flex';
              successMessage.style.alignItems = 'center';
              successMessage.style.gap = '10px';
              document.body.appendChild(successMessage);
              
              // Remove the message after 3 seconds
              setTimeout(() => {
                successMessage.style.opacity = '0';
                successMessage.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                successMessage.style.transform = 'translateX(-50%) translateY(-20px)';
                setTimeout(() => {
                  if (successMessage.parentNode) {
                    document.body.removeChild(successMessage);
                  }
                }, 500);
              }, 3000);
            } else {
              // For autosave just show the indicator
              showSavedIndicator();
            }
          } else {
            if (!isAutosave) {
              alert('Error saving data: ' + (data.message || 'Unknown error'));
              showSaveErrorIndicator();
            } else {
              showSaveErrorIndicator();
            }
          }
        })
        .catch(error => {
          console.error('Error saving form:', error);
          
          if (!isAutosave) {
            alert('Error saving form: ' + error.message);
          }
          
          showSaveErrorIndicator();
        });
        
        return false;
        
      } catch (error) {
        console.error('Error in validateAndSubmitAjax:', error);
        
        if (!isAutosave) {
          alert('Error preparing form submission: ' + error.message);
        }
        
        showSaveErrorIndicator();
        return false;
      }
    }
    
    function filterLearningOutcomes() {
      const selectedTheme = document.getElementById('themeName').value;
      const outcomeWrappers = document.querySelectorAll('.learning-outcome-wrapper');
      
      console.log('Filtering for theme:', selectedTheme);
      console.log('Found wrappers:', outcomeWrappers.length);

      outcomeWrappers.forEach((wrapper, index) => {
        const wrapperTheme = wrapper.dataset.theme;
        const isSelected = wrapperTheme === selectedTheme;
        
        console.log(`Wrapper ${index}: theme="${wrapperTheme}", selected=${isSelected}`);
        
        wrapper.style.display = isSelected ? 'block' : 'none';
        
        // Enable/disable form fields based on selection
        const themeFields = wrapper.querySelectorAll('.theme-field');
        themeFields.forEach(field => {
          field.disabled = !isSelected;
          // Clear values for non-selected themes
          if (!isSelected) {
            if (field.type === 'checkbox') {
              field.checked = false;
            } else if (field.type !== 'hidden' || !field.name.includes('[name]')) {
              field.value = '';
            }
          }
        });
        
        // Also disable mark inputs
        const markInputs = wrapper.querySelectorAll('.marks-input');
        markInputs.forEach(input => {
          input.disabled = !isSelected;
          if (!isSelected) input.value = 0;
        });
      });
      
      // Initialize totals for the newly selected theme
      setTimeout(initializeAllTotals, 100); // Small delay to ensure DOM is updated
    }

    document.addEventListener('DOMContentLoaded', function() {
      filterLearningOutcomes();
      
      // Add hidden field with timestamp for updatedAt
      const form = document.getElementById('themeEvaluationForm');
      const updatedAtField = document.createElement('input');
      updatedAtField.type = 'hidden';
      updatedAtField.name = 'updatedAt';
      updatedAtField.value = new Date().toISOString();
      form.appendChild(updatedAtField);
      
      // Add special handler for Syam Basnet's data (roll number 1)
      document.getElementById('roll').addEventListener('change', function() {
        if (this.value.trim() === "1") {
          checkForSyamBasnetData();
        }
      });
      
      // Check URL parameters for auto-loading Syam's data
      const urlParams = new URLSearchParams(window.location.search);
      const autoLoadSyam = urlParams.get('autoLoadSyam');
      if (autoLoadSyam === 'true' || (document.getElementById('studentClass').value.trim() === "1" && 
          document.getElementById('subject').value.trim().toLowerCase() === "serofero")) {
        // Add a slight delay to ensure the form is fully loaded
        setTimeout(() => {
          document.getElementById('roll').value = "1";
          checkForSyamBasnetData();
        }, 500);
      }
      
      // Add click handlers for custom checkboxes as backup
      document.addEventListener('click', function(event) {
        if (event.target.classList.contains('checkbox-custom')) {
          // Find the associated checkbox input
          const checkboxInput = event.target.previousElementSibling;
          if (checkboxInput && checkboxInput.type === 'checkbox') {
            checkboxInput.checked = !checkboxInput.checked;
            // Trigger the onchange event manually
            const changeEvent = new Event('change', { bubbles: true });
            checkboxInput.dispatchEvent(changeEvent);
          }
        }
      });
      
      // Initialize all totals calculations
      initializeAllTotals();
    });
    
    function initializeAllTotals() {
      // Find the active wrapper
      const activeWrapper = document.querySelector('.learning-outcome-wrapper[style*="display: block"], .learning-outcome-wrapper[style*="display:block"]');
      if (!activeWrapper) return;
      
      const themeIndex = activeWrapper.dataset.themeIndex;
      
      // Find all outcome sections in the active wrapper
      const outcomeContainers = activeWrapper.querySelectorAll('.learning-outcome-section');
      
      outcomeContainers.forEach((container, outcomeIndex) => {
        // Update before intervention totals
        updateLearningOutcomeTotal(outcomeIndex, 'Before');
        // Update after intervention totals
        updateLearningOutcomeTotal(outcomeIndex, 'After');
      });
      
      // Calculate overall totals
      calculateOverallTotals();
    }

    function updateMarks(input, outcomeIndex, indicatorIndex, timing) {
      // Ensure the input value is valid
      let value = parseFloat(input.value) || 0;
      const maxMarks = parseFloat(input.dataset.maxMarks) || 0;
      
      // Cap the value at the maximum marks
      if (value > maxMarks) {
        value = maxMarks;
        input.value = maxMarks;
      }
      
      // Ensure value is not negative
      if (value < 0) {
        value = 0;
        input.value = 0;
      }
      
      console.log('Input value changed:', {
        value: value,
        maxMarks: maxMarks,
        timing: timing,
        outcomeIndex: outcomeIndex,
        indicatorIndex: indicatorIndex
      });
      
      // Set the appropriate field name based on timing (Before or After intervention)
      const fieldName = timing === 'Before' ? 
        `subjects[0][themes][0][learningOutcomes][${outcomeIndex}][indicators][${indicatorIndex}][marksBeforeIntervention]` :
        `subjects[0][themes][0][learningOutcomes][${outcomeIndex}][indicators][${indicatorIndex}][marksAfterIntervention]`;
      
      // Get the hidden input field - try multiple approaches to find it
      let inputField = null;
      
      // Look for hidden field with matching name pattern in the same cell
      const cell = input.closest('td');
      if (cell) {
        inputField = cell.querySelector(`input[name$="[marks${timing}Intervention]"]`);
      }
      
      // If not found, try to find by name in the entire active wrapper
      if (!inputField || inputField.type !== 'hidden') {
        const activeWrapper = document.querySelector('.learning-outcome-wrapper[style*="display: block"]');
        if (activeWrapper) {
          // Create a partial name match for the field
          const partialName = `[${outcomeIndex}][indicators][${indicatorIndex}][marks${timing}Intervention]`;
          inputField = activeWrapper.querySelector(`input[name*="${partialName}"]`);
        }
      }
      
      // Set the value based on input value
      if (inputField && inputField.type === 'hidden') {
        inputField.value = value;
        console.log('Updated hidden field value:', inputField.value);
      } else {
        console.warn('Could not find hidden input field for', fieldName);
        
        // Create the field if it doesn't exist
        if (cell && !inputField) {
          inputField = document.createElement('input');
          inputField.type = 'hidden';
          inputField.name = fieldName;
          inputField.value = value;
          cell.appendChild(inputField);
          console.log('Created missing hidden field:', fieldName);
        }
      }
      
      // Update total for this learning outcome
      updateLearningOutcomeTotal(outcomeIndex, timing);
      
      // Update overall theme totals
      calculateOverallTotals();
    }
    
    function updateLearningOutcomeTotal(outcomeIndex, timing) {
      // Get the currently active wrapper
      const activeWrapper = document.querySelector('.learning-outcome-wrapper[style*="display: block"], .learning-outcome-wrapper[style*="display:block"]');
      if (!activeWrapper) return;
      
      const themeIndex = activeWrapper.dataset.themeIndex;
      const totalId = timing === 'Before' ? `totalBefore_${themeIndex}_${outcomeIndex}` : `totalAfter_${themeIndex}_${outcomeIndex}`;
      const inputSelector = timing === 'Before' ? '.indicator-before' : '.indicator-after';
      const totalField = document.getElementById(totalId);
      
      if (!totalField) return;
      
      // Get all indicators for this learning outcome within the active wrapper
      const outcomeSection = totalField.closest('.learning-outcome-section');
      const inputs = outcomeSection.querySelectorAll(inputSelector);
      
      let total = 0;
      inputs.forEach(input => {
        // Add the input value to the total
        total += parseFloat(input.value) || 0;
      });
      
      // Update the hidden field for form submission
      totalField.value = total;
      
      // Update the display value in the outcome totals box
      const displayElement = document.getElementById(`outcome${timing}Display_${themeIndex}_${outcomeIndex}`);
      if (displayElement) {
        displayElement.textContent = total;
      }
    }
    
    function calculateOverallTotals() {
      // Only calculate for visible learning outcome wrapper (the currently selected theme)
      const activeWrapper = document.querySelector('.learning-outcome-wrapper[style*="display: block"], .learning-outcome-wrapper[style*="display:block"]');
      if (!activeWrapper) return;
      
      const themeIndex = activeWrapper.dataset.themeIndex;
      let overallBefore = 0;
      let overallAfter = 0;
      let totalMaxMarks = 0;
      
      // Sum up all learning outcome totals for the active theme
      const beforeTotals = activeWrapper.querySelectorAll(`input[id^="totalBefore_${themeIndex}_"]`);
      const afterTotals = activeWrapper.querySelectorAll(`input[id^="totalAfter_${themeIndex}_"]`);
      
      beforeTotals.forEach(input => {
        overallBefore += parseFloat(input.value) || 0;
      });
      
      afterTotals.forEach(input => {
        overallAfter += parseFloat(input.value) || 0;
      });
      
      // Count total learning outcomes
      const totalOutcomes = beforeTotals.length;
      
      // Calculate total max marks
      const allMaxMarksInputs = activeWrapper.querySelectorAll('input[name$="[maxMarks]"]');
      allMaxMarksInputs.forEach(input => {
        totalMaxMarks += parseFloat(input.value) || 0;
      });
      
      // Update the overall total fields
      const overallBeforeField = document.getElementById(`overallTotalBefore_${themeIndex}`);
      const overallAfterField = document.getElementById(`overallTotalAfter_${themeIndex}`);
      const totalOutcomesElement = document.getElementById(`totalOutcomes_${themeIndex}`);
      const totalMaxMarksElement = document.getElementById(`totalMaxMarks_${themeIndex}`);
      
      if (overallBeforeField) overallBeforeField.value = overallBefore;
      if (overallAfterField) overallAfterField.value = overallAfter;
      if (totalOutcomesElement) totalOutcomesElement.textContent = totalOutcomes;
      if (totalMaxMarksElement) totalMaxMarksElement.textContent = totalMaxMarks;
    }
  </script>

  <!-- autofill name  -->
    <script>
        const subject = document.getElementById('subject').value.trim();
        const studentClass = document.getElementById('studentClass').value.trim();
        const section = document.getElementById('section').value.trim();
        const terminal = "FIRST";

        let debounceTimeout;
        let currentThemeData = null; // Store the currently loaded theme data
        let isEditMode = false; // Track if we're editing existing data

        // Function to check for any existing theme data for a student
        async function checkExistingThemeData(roll, studentClass, section) {
          try {
            // Show loading indicator
            showLoadingIndicator();
            
            // Fetch student data first to get basic info
            const res = await fetch(`/student_data/${encodeURIComponent(subject)}/${studentClass}/${encodeURIComponent(section)}?roll=${encodeURIComponent(roll)}`);
            if (!res.ok) {
              console.error('Error fetching student data:', res.statusText);
              hideLoadingIndicator();
              return null;
            }

            const data = await res.json();
            if (data && data.length > 0) {
              // Autofill the name field
              document.getElementById('name').value = data[0].name || '';
            }
            
            // Now check if any theme data exists for this student
            const themeDataResponse = await fetch(`/theme/student-themes?roll=${encodeURIComponent(roll)}&studentClass=${encodeURIComponent(studentClass)}&section=${encodeURIComponent(section)}`);
            
            if (!themeDataResponse.ok) {
              console.error('Error checking theme data:', themeDataResponse.statusText);
              hideLoadingIndicator();
              return null;
            }
            
            const responseData = await themeDataResponse.json();
            hideLoadingIndicator();
            return responseData;
          } catch (error) {
            console.error('Error checking existing theme data:', error);
            hideLoadingIndicator();
            return null;
          }
        }
        
        // Show loading indicator for data operations
        function showLoadingIndicator() {
          let loader = document.getElementById('data-loading-indicator');
          if (!loader) {
            loader = document.createElement('div');
            loader.id = 'data-loading-indicator';
            loader.innerHTML = `
              <div class="spinner"></div>
              <div class="loading-text">Loading data...</div>
            `;
            loader.style.position = 'fixed';
            loader.style.top = '50%';
            loader.style.left = '50%';
            loader.style.transform = 'translate(-50%, -50%)';
            loader.style.background = 'rgba(255, 255, 255, 0.9)';
            loader.style.padding = '20px 30px';
            loader.style.borderRadius = '10px';
            loader.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
            loader.style.zIndex = '1000';
            loader.style.display = 'flex';
            loader.style.flexDirection = 'column';
            loader.style.alignItems = 'center';
            loader.style.gap = '10px';
            document.body.appendChild(loader);
            
            // Add spinner styles
            const style = document.createElement('style');
            style.textContent = `
              .spinner {
                width: 30px;
                height: 30px;
                border: 3px solid rgba(52, 152, 219, 0.3);
                border-radius: 50%;
                border-top-color: #3498db;
                animation: spin 1s ease-in-out infinite;
              }
              
              @keyframes spin {
                to { transform: rotate(360deg); }
              }
              
              .loading-text {
                color: #2c3e50;
                font-weight: 500;
              }
            `;
            document.head.appendChild(style);
          } else {
            loader.style.display = 'flex';
          }
        }
        
        // Hide loading indicator
        function hideLoadingIndicator() {
          const loader = document.getElementById('data-loading-indicator');
          if (loader) {
            loader.style.display = 'none';
          }
        }
        
        // Function to populate the form with theme data
        function populateFormWithThemeData(themeData) {
          try {
            console.log("Populating form with theme data:", themeData);
            
            // Store the current theme data for future reference
            currentThemeData = themeData;
            isEditMode = true;
            
            // First, make sure a theme is selected
            const themeName = document.getElementById('themeName').value;
            if (!themeName) {
              alert("Please select a theme first before loading previous data");
              return;
            }
            
            // Get the active wrapper for the selected theme
            const activeWrapper = document.querySelector('.learning-outcome-wrapper[style*="display: block"]');
            if (!activeWrapper) {
              console.error("No active learning outcome wrapper found");
              return;
            }
            
            const themeIndex = activeWrapper.dataset.themeIndex;
            
            // Map learning outcomes to their names for easy lookup
            const learningOutcomeMap = {};
            themeData.learningOutcomes.forEach(outcome => {
              learningOutcomeMap[outcome.name] = outcome;
            });
            
            // Process each learning outcome section in the active wrapper
            const outcomeContainers = activeWrapper.querySelectorAll('.learning-outcome-section');
            
            outcomeContainers.forEach((container, index) => {
              // Get the learning outcome name from the h2
              const outcomeNameElement = container.querySelector('h2');
              if (!outcomeNameElement) return;
              
              const outcomeName = outcomeNameElement.textContent.trim();
              const outcome = learningOutcomeMap[outcomeName];
              
              // Skip if no data for this outcome
              if (!outcome) return;
              
              // Set the evaluation date if it exists
              const dateInput = container.querySelector('input[type="date"]');
              if (dateInput && outcome.evaluationDate) {
                const date = new Date(outcome.evaluationDate);
                if (!isNaN(date)) {
                  // Format date as YYYY-MM-DD
                  const formattedDate = date.toISOString().split('T')[0];
                  dateInput.value = formattedDate;
                }
              }
              
              // Create indicator map for easy lookup
              const indicatorMap = {};
              if (outcome.indicators) {
                outcome.indicators.forEach(indicator => {
                  indicatorMap[indicator.name] = indicator;
                });
              }
              
              // Get the table for this learning outcome
              const table = container.querySelector('table.evaluation-table');
              if (!table) return;
              
              // Get table header row to match indicators by name
              const headerRow = table.querySelector('thead tr');
              if (!headerRow) return;
              
              const headerCells = headerRow.querySelectorAll('th');
              const indicatorNames = Array.from(headerCells)
                .slice(0, -1) // Exclude last column (Total Marks)
                .map(cell => cell.textContent.trim());
              
              // Process 'Before Intervention' inputs
              const beforeRow = table.querySelector('tbody tr:first-child');
              if (beforeRow) {
                const beforeInputs = beforeRow.querySelectorAll('.marks-input.indicator-before');
                
                beforeInputs.forEach((input, i) => {
                  if (i >= indicatorNames.length) return;
                  
                  const indicatorName = indicatorNames[i];
                  const indicator = indicatorMap[indicatorName];
                  
                  if (indicator && indicator.marksBeforeIntervention !== undefined) {
                    // Set the value directly to the marks
                    input.value = parseFloat(indicator.marksBeforeIntervention) || 0;
                    
                    // Also update the hidden input
                    const hiddenInput = input.closest('td').querySelector('input[type="hidden"]');
                    if (hiddenInput) {
                      hiddenInput.value = input.value;
                    }
                  }
                });
                
                // Update total before intervention
                const totalBeforeInput = beforeRow.querySelector(`input[id^="totalBefore_${themeIndex}_"]`);
                if (totalBeforeInput && outcome.totalMarksBeforeIntervention !== undefined) {
                  totalBeforeInput.value = outcome.totalMarksBeforeIntervention;
                }
              }
              
              // Process 'After Intervention' inputs
              const afterRow = table.querySelector('tbody tr:nth-child(3)');
              if (afterRow) {
                const afterInputs = afterRow.querySelectorAll('.marks-input.indicator-after');
                
                afterInputs.forEach((input, i) => {
                  if (i >= indicatorNames.length) return;
                  
                  const indicatorName = indicatorNames[i];
                  const indicator = indicatorMap[indicatorName];
                  
                  if (indicator && indicator.marksAfterIntervention !== undefined) {
                    // Set the value directly to the marks
                    input.value = parseFloat(indicator.marksAfterIntervention) || 0;
                    
                    // Also update the hidden input
                    const hiddenInput = input.closest('td').querySelector('input[type="hidden"]');
                    if (hiddenInput) {
                      hiddenInput.value = input.value;
                    }
                  }
                });
                
                // Update total after intervention
                const totalAfterInput = afterRow.querySelector(`input[id^="totalAfter_${themeIndex}_"]`);
                if (totalAfterInput && outcome.totalMarksAfterIntervention !== undefined) {
                  totalAfterInput.value = outcome.totalMarksAfterIntervention;
                }
              }
              
              // Process tools used inputs
              const toolsRow = table.querySelector('tbody tr:nth-child(5)');
              if (toolsRow && outcome.indicators) {
                const toolsInputs = toolsRow.querySelectorAll('input[type="text"]');
                
                toolsInputs.forEach((input, i) => {
                  if (i >= indicatorNames.length) return;
                  
                  const indicatorName = indicatorNames[i];
                  const indicator = indicatorMap[indicatorName];
                  
                  if (indicator && indicator.toolsUsed) {
                    input.value = indicator.toolsUsed;
                  }
                });
              }
              
              // Update the outcome totals display
              updateLearningOutcomeTotal(index, 'Before');
              updateLearningOutcomeTotal(index, 'After');
            });
            
            // Update overall theme totals
            if (themeData.overallTotalBefore !== undefined) {
              const overallBeforeField = document.getElementById(`overallTotalBefore_${themeIndex}`);
              if (overallBeforeField) {
                overallBeforeField.value = themeData.overallTotalBefore;
              }
            }
            
            if (themeData.overallTotalAfter !== undefined) {
              const overallAfterField = document.getElementById(`overallTotalAfter_${themeIndex}`);
              if (overallAfterField) {
                overallAfterField.value = themeData.overallTotalAfter;
              }
            }
            
            // Calculate overall totals to make sure everything is in sync
            calculateOverallTotals();
            
            // Show edit mode notification
            showEditModeNotification();
            
            // Show a success message with animation
            const toastMessage = document.createElement('div');
            toastMessage.className = 'toast-message';
            toastMessage.innerHTML = '<i class="fa fa-check-circle"></i> Previous data loaded successfully';
            toastMessage.style.position = 'fixed';
            toastMessage.style.top = '20px';
            toastMessage.style.left = '50%';
            toastMessage.style.transform = 'translateX(-50%)';
            toastMessage.style.background = 'rgba(76, 175, 80, 0.9)';
            toastMessage.style.color = 'white';
            toastMessage.style.padding = '12px 24px';
            toastMessage.style.borderRadius = '8px';
            toastMessage.style.zIndex = '1000';
            toastMessage.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            toastMessage.style.display = 'flex';
            toastMessage.style.alignItems = 'center';
            toastMessage.style.gap = '10px';
            document.body.appendChild(toastMessage);
            
            // Remove the message after 3 seconds with animation
            setTimeout(() => {
              toastMessage.style.opacity = '0';
              toastMessage.style.transform = 'translateX(-50%) translateY(-20px)';
              toastMessage.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
              setTimeout(() => {
                if (toastMessage.parentNode) {
                  document.body.removeChild(toastMessage);
                }
              }, 500);
            }, 3000);
            
          } catch (error) {
            console.error('Error populating form with theme data:', error);
            hideLoadingIndicator();
          }
        }

        const rollInput = document.getElementById('roll');
        const themeNameSelect = document.getElementById('themeName');
        
        // Load previous data when roll number changes or theme changes
        function loadPreviousData() {
          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(async () => {
            const rollValue = rollInput.value.trim();
            const themeValue = themeNameSelect.value.trim();
            if (!rollValue) {
              // Reset the form if roll number is cleared
              resetForm();
              return;
            }
            
            // Special case for Syam Basnet - roll number 1
            if (rollValue === "1" && 
                document.getElementById('studentClass').value.trim().toLowerCase() === "1" &&
                document.getElementById('subject').value.trim().toLowerCase() === "serofero") {
              
              // Set student name to Syam Basnet
              document.getElementById('name').value = "Syam Basnet";
              
              // Auto-select the first available theme if none is selected
              if (!themeValue) {
                const themeSelect = document.getElementById('themeName');
                if (themeSelect.options.length > 1) {
                  themeSelect.selectedIndex = 1; // Select first theme (index 1, after the placeholder)
                  // Trigger change event to load the theme content
                  themeSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
              }
              
              // If theme is selected now, proceed with loading specific data
              const selectedTheme = document.getElementById('themeName').value;
              if (selectedTheme) {
                showLoadingIndicator();
                
                try {
                  // Fetch Syam's data
                  const themeRes = await fetch(`/theme/previous-data?roll=1&subject=Serofero&themeName=${encodeURIComponent(selectedTheme)}&studentClass=1&section=Moon`);
                  
                  if (themeRes.ok) {
                    const themeData = await themeRes.json();
                    if (themeData.success && themeData.found) {
                      // Populate form with the retrieved data
                      populateFormWithThemeData(themeData.themeData);
                      
                      // Show edit mode notification and update button
                      showEditModeNotification();
                      updateSubmitButtonText(true);
                      isEditMode = true;
                    }
                  }
                } catch (error) {
                  console.error('Error fetching Syam Basnet data:', error);
                } finally {
                  hideLoadingIndicator();
                }
              }
            }
            
            try {
              // First, check for any existing theme data for this student
              const studentThemeData = await checkExistingThemeData(
                rollValue, 
                document.getElementById('studentClass').value.trim(), 
                document.getElementById('section').value.trim()
              );
              
              // If we have student data but no theme selected yet
              if (studentThemeData && studentThemeData.success) {
                // If there is existing data, show a notification of available themes
                if (studentThemeData.themes && studentThemeData.themes.length > 0) {
                  showThemeNotification(studentThemeData.themes);
                  
                  // Update the Submit button text to reflect that we're in edit mode
                  updateSubmitButtonText(true);
                  
                  // Automatically select the first theme if none is selected
                  if (!themeValue) {
                    const themeSelect = document.getElementById('themeName');
                    
                    // Find the first theme in the dropdown that matches an available theme
                    const availableTheme = studentThemeData.themes[0];
                    const matchingOption = Array.from(themeSelect.options).find(
                      option => option.value === availableTheme.name
                    );
                    
                    if (matchingOption) {
                      // Select this theme
                      themeSelect.value = availableTheme.name;
                      
                      // Trigger change event to load the theme content
                      const event = new Event('change', { bubbles: true });
                      themeSelect.dispatchEvent(event);
                      
                      console.log(`Auto-selected theme: ${availableTheme.name}`);
                      
                      // Show notification
                      showCustomNotification(
                        "Auto-loaded Data", 
                        `Found existing data for ${studentThemeData.studentName || 'this student'} - loaded theme: ${availableTheme.name}`, 
                        "success"
                      );
                    }
                  }
                } else {
                  // No existing themes, reset to create mode
                  updateSubmitButtonText(false);
                }
              }
              
              // If both roll and theme are selected, load specific theme data
              if (rollValue && themeValue) {
                showLoadingIndicator();
                
                try {
                  // Fetch specific theme data
                  const themeRes = await fetch(`/theme/previous-data?roll=${encodeURIComponent(rollValue)}&subject=${encodeURIComponent(subject)}&themeName=${encodeURIComponent(themeValue)}&studentClass=${encodeURIComponent(studentClass)}&section=${encodeURIComponent(section)}`);
                  
                  if (!themeRes.ok) {
                    hideLoadingIndicator();
                    return;
                  }
                  
                  const themeData = await themeRes.json();
                  if (themeData.success && themeData.found) {
                    // Update student name if it's not already set
                    if (!document.getElementById('name').value && themeData.studentName) {
                      document.getElementById('name').value = themeData.studentName;
                    }
                    
                    // Populate form with the retrieved data
                    populateFormWithThemeData(themeData.themeData);
                    
                    // Show edit mode notification and update button
                    showEditModeNotification();
                    updateSubmitButtonText(true);
                    isEditMode = true;
                  } else {
                    // No data found for this specific theme
                    isEditMode = false;
                    updateSubmitButtonText(false);
                  }
                } catch (error) {
                  console.error('Error fetching specific theme data:', error);
                } finally {
                  hideLoadingIndicator();
                }
              }
            } catch (error) {
              console.error('Error in loadPreviousData:', error);
              hideLoadingIndicator();
            }
          }, 600);
        }
        
        // Reset the form to create mode
        function resetForm() {
          isEditMode = false;
          currentThemeData = null;
          
          // Hide the edit mode notification if visible
          const editNotice = document.getElementById('edit-mode-notice');
          if (editNotice) {
            editNotice.style.display = 'none';
          }
          
          // Reset theme dropdown styling
          const themeSelect = document.getElementById('themeName');
          Array.from(themeSelect.options).forEach(option => {
            option.style.backgroundColor = '';
            option.style.fontWeight = '';
            option.style.color = '';
            option.removeAttribute('data-has-evaluation');
            // Reset option text if it contains (eval)
            if (option.textContent.includes(' (')) {
              option.textContent = option.value;
            }
          });
          
          // Reset the submit button text
          updateSubmitButtonText(false);
          
          // Don't clear form fields - just reset the state
        }
        
        // Update the submit button text based on mode
        function updateSubmitButtonText(isEdit) {
          const submitButton = document.querySelector('.submit-btn');
          if (submitButton) {
            submitButton.textContent = isEdit ? 'Update Evaluation' : 'Save Evaluation';
          }
        }
        
        // Show notification when themes are available for editing and highlight options in dropdown
        function showThemeNotification(availableThemes) {
          // Create theme list for display
          const themeList = availableThemes.map(theme => 
            `<li style="margin: 5px 0;"><strong>${theme.name}</strong> (${theme.count} ${theme.count === 1 ? 'evaluation' : 'evaluations'})</li>`
          ).join('');
          
          // Create notification element
          let notification = document.getElementById('theme-notification');
          if (!notification) {
            notification = document.createElement('div');
            notification.id = 'theme-notification';
            notification.style.position = 'fixed';
            notification.style.top = '80px';
            notification.style.right = '20px';
            notification.style.maxWidth = '320px';
            notification.style.padding = '15px';
            notification.style.background = 'rgba(52, 152, 219, 0.95)';
            notification.style.color = 'white';
            notification.style.borderRadius = '8px';
            notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            notification.style.zIndex = '1000';
            notification.style.fontSize = '0.9rem';
            notification.style.animationName = 'fadeInRight';
            notification.style.animationDuration = '0.5s';
            document.body.appendChild(notification);
          }
          
          notification.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 8px; font-size: 1.1rem;">Previous Data Available</div>
            <p style="margin: 0 0 8px 0;">This student has existing evaluations for:</p>
            <ul style="margin: 0; padding-left: 20px;">
              ${themeList}
            </ul>
            <p style="margin: 8px 0 0 0; font-style: italic;">Select a theme to edit previous data.</p>
          `;
          
          // Auto remove after 8 seconds
          setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
              if (notification.parentNode) {
                document.body.removeChild(notification);
              }
            }, 500);
          }, 8000);
          
          // Highlight themes with existing data in the dropdown
          highlightExistingThemes(availableThemes);
          
          // If there's just one theme, automatically select it
          if (availableThemes.length === 1) {
            const themeSelect = document.getElementById('themeName');
            const themeOption = Array.from(themeSelect.options).find(opt => opt.value === availableThemes[0].name);
            
            if (themeOption) {
              themeSelect.value = availableThemes[0].name;
              // Trigger the change event to load the appropriate outcomes
              const event = new Event('change', { bubbles: true });
              themeSelect.dispatchEvent(event);
            }
          }
        }
        
        // Highlight themes in the dropdown that have existing data
        function highlightExistingThemes(availableThemes) {
          const themeSelect = document.getElementById('themeName');
          
          // First, reset all options to default style
          Array.from(themeSelect.options).forEach(option => {
            option.style.backgroundColor = '';
            option.style.fontWeight = '';
            option.style.color = '';
            option.removeAttribute('data-has-evaluation');
          });
          
          // Then highlight options with existing data
          Array.from(themeSelect.options).forEach(option => {
            const theme = availableThemes.find(t => t.name === option.value);
            
            if (theme) {
              option.style.backgroundColor = 'rgba(46, 204, 113, 0.1)';
              option.style.fontWeight = 'bold';
              option.style.color = '#16a085';
              option.setAttribute('data-has-evaluation', 'true');
              option.textContent = `${option.value} (${theme.count} eval)`;
            }
          });
          
          // Add some styling to the select element itself to indicate it has data
          if (availableThemes.length > 0) {
            themeSelect.style.borderColor = '#2ecc71';
            themeSelect.style.boxShadow = '0 0 0 3px rgba(46, 204, 113, 0.1)';
          }
          
          // Add styles for the dropdown to ensure highlighting works
          const styleEl = document.createElement('style');
          styleEl.textContent = `
            #themeName option[data-has-evaluation="true"] {
              background-color: rgba(46, 204, 113, 0.1);
              font-weight: bold;
              color: #16a085;
            }
          `;
          document.head.appendChild(styleEl);
        }
        
        // Show edit mode notification
        function showEditModeNotification() {
          let editNotice = document.getElementById('edit-mode-notice');
          if (!editNotice) {
            editNotice = document.createElement('div');
            editNotice.id = 'edit-mode-notice';
            editNotice.style.margin = '15px 0';
            editNotice.style.padding = '10px 15px';
            editNotice.style.background = 'rgba(230, 126, 34, 0.1)';
            editNotice.style.borderLeft = '4px solid #e67e22';
            editNotice.style.borderRadius = '6px';
            editNotice.style.color = '#e67e22';
            editNotice.style.fontWeight = 'bold';
            editNotice.style.display = 'flex';
            editNotice.style.alignItems = 'center';
            editNotice.style.justifyContent = 'space-between';
            
            const editIcon = document.createElement('span');
            editIcon.style.marginRight = '10px';
            editIcon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 4H4C3.46957 4 2.96086 4.21071 2.58579 4.58579C2.21071 4.96086 2 5.46957 2 6V20C2 20.5304 2.21071 21.0391 2.58579 21.4142C2.96086 21.7893 3.46957 22 4 22H18C18.5304 22 19.0391 21.7893 19.4142 21.4142C19.7893 21.0391 20 20.5304 20 20V13" stroke="#e67e22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18.5 2.5C18.8978 2.10217 19.4374 1.87868 20 1.87868C20.5626 1.87868 21.1022 2.10217 21.5 2.5C21.8978 2.89782 22.1213 3.43739 22.1213 4C22.1213 4.56261 21.8978 5.10218 21.5 5.5L12 15L8 16L9 12L18.5 2.5Z" stroke="#e67e22" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
            
            const textContent = document.createElement('div');
            textContent.textContent = 'EDIT MODE: You are updating an existing evaluation';
            
            const lastUpdated = document.createElement('div');
            lastUpdated.style.fontSize = '0.8rem';
            lastUpdated.style.fontWeight = 'normal';
            lastUpdated.style.marginTop = '3px';
            
            // Add timestamp if available
            if (currentThemeData && currentThemeData.updatedAt) {
              const date = new Date(currentThemeData.updatedAt);
              lastUpdated.textContent = `Last updated: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
            }
            
            textContent.appendChild(lastUpdated);
            
            editNotice.appendChild(editIcon);
            editNotice.appendChild(textContent);
            
            // Add a close button
            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.style.background = 'transparent';
            closeBtn.style.border = 'none';
            closeBtn.style.color = '#e67e22';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.fontSize = '16px';
            closeBtn.style.padding = '0';
            closeBtn.style.marginLeft = '10px';
            closeBtn.innerHTML = '×';
            closeBtn.onclick = function() {
              editNotice.style.display = 'none';
            };
            
            editNotice.appendChild(closeBtn);
            
            // Insert after the form header
            const formHeader = document.querySelector('.form-header');
            formHeader.parentNode.insertBefore(editNotice, formHeader.nextSibling);
          } else {
            // Update timestamp if needed
            const lastUpdated = editNotice.querySelector('div > div');
            if (lastUpdated && currentThemeData && currentThemeData.updatedAt) {
              const date = new Date(currentThemeData.updatedAt);
              lastUpdated.textContent = `Last updated: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
            }
            
            editNotice.style.display = 'flex';
          }
        }
        
        rollInput.addEventListener('input', loadPreviousData);
        themeNameSelect.addEventListener('change', loadPreviousData);
        
        // Special function to check for and load Syam Basnet's data
        async function checkForSyamBasnetData() {
          const rollValue = document.getElementById('roll').value.trim();
          const studentClass = document.getElementById('studentClass').value.trim();
          const subject = document.getElementById('subject').value.trim();
          
          // Case-insensitive check for class 1 and subject serofero
          if (rollValue === "1" && 
              (studentClass.toLowerCase() === "1" || studentClass.toLowerCase().includes("1")) && 
              (subject.toLowerCase() === "serofero" || subject.toLowerCase().includes("sero"))) {
            
            // Set student name
            document.getElementById('name').value = "Syam Basnet";
            
            // Show notification for Syam's data
            showCustomNotification("Syam Basnet's data found", 
              "Loading existing theme evaluations for Syam Basnet in Class 1 Moon", 
              "info");
            
            // Get all available themes for this subject/class
            try {
              showLoadingIndicator();
              
              // First try to get all themes for the student
              const themesRes = await fetch(`/theme/student-themes?roll=1&studentClass=1&section=Moon`);
              
              if (themesRes.ok) {
                const themesData = await themesRes.json();
                
                if (themesData.success && themesData.themes && themesData.themes.length > 0) {
                  // Show available themes
                  showThemeNotification(themesData.themes);
                  
                  // Auto-select the first theme if none is selected
                  const themeSelect = document.getElementById('themeName');
                  if (!themeSelect.value && themeSelect.options.length > 1) {
                    themeSelect.selectedIndex = 1;
                    themeSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Now load the specific theme data
                    const selectedTheme = themeSelect.value;
                    const themeRes = await fetch(`/theme/previous-data?roll=1&subject=Serofero&themeName=${encodeURIComponent(selectedTheme)}&studentClass=1&section=Moon`);
                    
                    if (themeRes.ok) {
                      const themeData = await themeRes.json();
                      if (themeData.success && themeData.found) {
                        populateFormWithThemeData(themeData.themeData);
                        showEditModeNotification();
                        updateSubmitButtonText(true);
                        isEditMode = true;
                      }
                    }
                  }
                }
              }
            } catch (error) {
              console.error("Error loading Syam Basnet's data:", error);
              showCustomNotification("Error", "Could not load Syam Basnet's data", "error");
            } finally {
              hideLoadingIndicator();
            }
          }
        }

        // AUTOSAVE LOGIC
        let autosaveTimeout;
        const form = document.getElementById('themeEvaluationForm');
        function autosaveForm() {
          clearTimeout(autosaveTimeout);
          autosaveTimeout = setTimeout(async () => {
            // Only autosave if roll and theme are present
            const rollValue = rollInput.value.trim();
            const themeValue = themeNameSelect.value.trim();
            if (!rollValue || !themeValue) return;
            
            try {
              // Show a subtle saving indicator
              showSavingIndicator();
              
              // Try the main autosave method first
              try {
                // Use the validateAndSubmitAjax method to prepare data correctly
                // But create a fake event object
                const fakeEvent = {
                  preventDefault: () => {}
                };
                
                // Call the method that already handles proper data formatting
                validateAndSubmitAjax(fakeEvent, true);
              } catch (err) {
                console.error('Main autosave error:', err);
                
                // Fall back to simple autosave endpoint
                console.log('Trying fallback autosave method');
                const simpleData = {
                  roll: rollValue,
                  name: document.getElementById('name').value.trim(),
                  studentClass: document.getElementById('studentClass').value.trim(),
                  section: document.getElementById('section').value.trim(),
                  subject: document.getElementById('subject').value.trim(),
                  themeName: themeValue,
                  isEdit: isEditMode
                };
                
                const response = await fetch('/theme/autosave', {
                  method: 'POST',
                  body: JSON.stringify(simpleData),
                  headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                  }
                });
                
                if (response.ok) {
                  showSavedIndicator();
                }
              }
            } catch (err) {
              console.error('Autosave error:', err);
              // Show error indicator
              showSaveErrorIndicator();
            }
          }, 1200); // Debounce autosave
        }
        
        // Show an indicator while saving
        function showSavingIndicator() {
          let indicator = document.getElementById('autosave-indicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'autosave-indicator';
            indicator.style.position = 'fixed';
            indicator.style.bottom = '24px';
            indicator.style.right = '24px';
            indicator.style.background = 'rgba(52,152,219,0.95)';
            indicator.style.color = 'white';
            indicator.style.padding = '10px 24px';
            indicator.style.borderRadius = '8px';
            indicator.style.fontWeight = 'bold';
            indicator.style.zIndex = '1000';
            indicator.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            indicator.style.display = 'flex';
            indicator.style.alignItems = 'center';
            indicator.style.gap = '8px';
            document.body.appendChild(indicator);
          }
          
          indicator.innerHTML = `
            <div class="spinner" style="width:16px;height:16px;border:2px solid rgba(255,255,255,0.3);border-radius:50%;border-top-color:white;animation:spin 0.8s linear infinite;"></div>
            <span>Saving...</span>
          `;
          indicator.style.opacity = '1';
          indicator.style.transition = 'opacity 0.2s ease';
        }
        
        // Show saved indicator
        function showSavedIndicator() {
          let indicator = document.getElementById('autosave-indicator');
          if (!indicator) {
            showSavingIndicator();
            indicator = document.getElementById('autosave-indicator');
          }
          
          indicator.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M20 6L9 17L4 12" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Saved</span>
          `;
          
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 1800);
        }
        
        // Show error indicator for save failures
        function showSaveErrorIndicator() {
          let indicator = document.getElementById('autosave-indicator');
          if (!indicator) {
            showSavingIndicator();
            indicator = document.getElementById('autosave-indicator');
          }
          
          indicator.style.background = 'rgba(231,76,60,0.95)';
          indicator.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 9V13M12 17H12.01M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Error saving</span>
          `;
          
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 3000);
        }

        // Show a 'Saved' indicator
        function showSavedIndicator() {
          let indicator = document.getElementById('autosave-indicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'autosave-indicator';
            indicator.textContent = 'Saved';
            indicator.style.position = 'fixed';
            indicator.style.bottom = '24px';
            indicator.style.right = '24px';
            indicator.style.background = 'rgba(52,152,219,0.95)';
            indicator.style.color = 'white';
            indicator.style.padding = '10px 24px';
            indicator.style.borderRadius = '8px';
            indicator.style.fontWeight = 'bold';
            indicator.style.zIndex = '1000';
            indicator.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
            document.body.appendChild(indicator);
          }
          indicator.style.opacity = '1';
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 1800);
        }
        
        // Show a custom notification with title and message
        function showCustomNotification(title, message, type = 'info') {
          let notificationId = 'custom-notification-' + Date.now();
          let notification = document.createElement('div');
          notification.id = notificationId;
          notification.style.position = 'fixed';
          notification.style.top = '80px';
          notification.style.right = '20px';
          notification.style.maxWidth = '320px';
          notification.style.padding = '15px';
          notification.style.color = 'white';
          notification.style.borderRadius = '8px';
          notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
          notification.style.zIndex = '1000';
          notification.style.fontSize = '0.9rem';
          notification.style.animationName = 'fadeInRight';
          notification.style.animationDuration = '0.5s';
          notification.style.display = 'flex';
          notification.style.flexDirection = 'column';
          
          // Set color based on type
          if (type === 'error') {
            notification.style.background = 'rgba(231, 76, 60, 0.95)';
          } else if (type === 'success') {
            notification.style.background = 'rgba(46, 204, 113, 0.95)';
          } else if (type === 'warning') {
            notification.style.background = 'rgba(241, 196, 15, 0.95)';
          } else {
            notification.style.background = 'rgba(52, 152, 219, 0.95)'; // info
          }
          
          // Add content
          notification.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px; font-size: 1rem;">${title}</div>
            <div>${message}</div>
          `;
          
          // Add close button
          const closeBtn = document.createElement('button');
          closeBtn.innerHTML = '×';
          closeBtn.style.position = 'absolute';
          closeBtn.style.top = '5px';
          closeBtn.style.right = '5px';
          closeBtn.style.background = 'transparent';
          closeBtn.style.border = 'none';
          closeBtn.style.color = 'white';
          closeBtn.style.fontSize = '20px';
          closeBtn.style.cursor = 'pointer';
          closeBtn.style.padding = '0';
          closeBtn.style.width = '20px';
          closeBtn.style.height = '20px';
          closeBtn.style.lineHeight = '20px';
          closeBtn.style.textAlign = 'center';
          closeBtn.onclick = function() {
            document.body.removeChild(notification);
          };
          
          notification.appendChild(closeBtn);
          document.body.appendChild(notification);
          
          // Auto-remove after 5 seconds
          setTimeout(() => {
            if (notification.parentNode) {
              notification.style.opacity = '0';
              notification.style.transition = 'opacity 0.5s ease';
              setTimeout(() => {
                if (notification.parentNode) {
                  document.body.removeChild(notification);
                }
              }, 500);
            }
          }, 5000);
          
          return notificationId;
        }

        // Listen for changes on all form fields for autosave
        form.addEventListener('input', autosaveForm);
        form.addEventListener('change', autosaveForm);
        
        // Add specific listeners for checkboxes to ensure they trigger autosave
        document.querySelectorAll('.custom-checkbox input[type="checkbox"]').forEach(checkbox => {
          checkbox.addEventListener('change', function() {
            console.log('Checkbox changed, triggering autosave');
            autosaveForm();
          });
        });
    </script>
    
    <style>
      /* Toast message animations */
      .toast-message {
        animation: fadeIn 0.5s ease;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translate(-50%, -20px); }
        to { opacity: 1; transform: translate(-50%, 0); }
      }
      
      @keyframes fadeInRight {
        from { opacity: 0; transform: translateX(30px); }
        to { opacity: 1; transform: translateX(0); }
      }
      
      /* Autosave indicator */
      #autosave-indicator {
        opacity: 0;
        transition: opacity 0.5s ease, transform 0.3s ease;
      }
      
      #autosave-indicator.visible {
        opacity: 1;
        transform: translateY(0);
      }
      
      /* Edit mode styling */
      #edit-mode-notice {
        animation: highlight 2s ease;
      }
      
      @keyframes highlight {
        0% { background-color: rgba(230, 126, 34, 0.4); }
        100% { background-color: rgba(230, 126, 34, 0.1); }
      }
      
      /* Loading spinner animation */
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      /* Theme select highlighting */
      #themeName option[data-has-evaluation="true"] {
        background-color: rgba(46, 204, 113, 0.1);
        font-weight: bold;
        color: #16a085;
      }
      
      /* Animated checkbox checkmarks */
      .custom-checkbox input[type="checkbox"]:checked + .checkbox-custom::after {
        animation: checkmark-pop 0.3s ease-out;
      }
      
      @keyframes checkmark-pop {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        50% { transform: translate(-50%, -50%) scale(1.2); }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      }
      
      /* Improve focus states for better accessibility */
      input:focus, select:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        transition: all 0.2s ease;
      }
      
      /* Make the form fields highlight when filled with data */
      input:not([type="checkbox"]):not(:placeholder-shown),
      select:not(:placeholder-shown) {
        border-color: #27ae60;
        background-color: rgba(46, 204, 113, 0.05);
      }
      
      /* Style submit button with animation */
      .submit-btn {
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease, transform 0.2s ease;
      }
      
      .submit-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 15px rgba(39, 174, 96, 0.4);
      }
      
      .submit-btn:active {
        transform: translateY(0);
      }
      
      .submit-btn::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.7s ease;
      }
      
      .submit-btn:hover::after {
        left: 100%;
      }
    </style>
</body>
</html>